<template>
  <link rel="stylesheet" href="./src/plugins/_utils/css/shared-styles.css">
  <div class="laPedale">
  </div>
</template>
<script>UseWebAudioControlsMidi = 1</script>
<script src="https://wasabi.i3s.unice.fr/WebAudioPluginBank/sdk/WebAudioSDK.js"></script>
<script>

  // Current document needs to be defined to get DOM access to imported HTML
  const _currentdoc = document.currentScript.ownerDocument;
  const pbplugintemplate = _currentdoc.querySelector(`template`);
  /**
   * This is a pedal factory. it creates a pedal === a PBPlugin using when the createPedal methode is called
   * 
  */
  class factory {
    /**
     * The createPedal function create an audio modules with a GUI that can be used in the Pedalboard. It needs :
     * @param {String} _tagname 
     * @param {String} _pluginName
     * @param {URL} _pluginUrl
     *  to : 
     * - Import a distant audioNode;
     * - Import and link its GUI;
     * - Wrap it in a PBPlugin
    */
    createPedal(_tagName, _pluginName, _pluginUrl) {
      // Register the x-custom element with the browser and associate the class created
      customElements.define(_tagName, class extends PBPlugin(HTMLElement) {
        constructor() {
          super();

          // Default values if non specified width/heigth nbinput/nboutput for pedal (fix wor wam DX7);
          this.w = 825;
          this.h = 115;

          this.params = '';
          this.node = '';
          this.paramsLoaded = '';
        }

        get is() { return this.nodeName.toLowerCase(); }

        // observedAttributes : Specify observed attributes so that attributeChangedCallback will work
        static get observedAttributes() { return ['params', 'dynamicparams']; }



        // Called if one of the observed attribute changed.
        attributeChangedCallback(name, oldValue, newValue, nbNodeIn) {
          console.log(`Custom element ${this.is} attributes changed.`);
            if(name ==="params"){
            try {
              console.log(`name: ${name}`);
              console.log(`oldValue:`, oldValue);
              console.log(`newValue:`, newValue);
              this.paramsLoaded = JSON.parse(newValue);
              console.log('this.paramsLoaded', this.paramsLoaded);
              console.log('thisNODE', this.node);
              
             this.node.setState(this.paramsLoaded);
            }
            catch (err) {
              console.log(err);
            }
          }
          else if(name ==="dynamicparams"){
            console.log(`name: ${name}`);
            console.log(`newValue:`, newValue);
              if(newValue == "numberOfInputs"){
                this.nbNodeIn = this.node.numberOfInputs;
                console.log(this.nbNodeIn)
                this.addInput(this.nbNodeIn - 1);
              }
          }

        }

        // called when the plugin is moved to another document
        adoptedCallback() {
          console.log(`Custom element ${this.is} moved to new page.`);
        }

        // Called when the pedal is disconnected from the dom 
        disconnectedCallback() {
          console.log(`Custom element ${this.is} removed from page.`);
        }

        // is called every time the element is inserted into the DOM. It is useful for running setup code, such as fetching resources or rendering.
        connectedCallback() {
          //  console.log(`Custom element ${this.is} added to page.`);
          // Select the template and clone it. Finally attach the cloned node to the shadowDOM's root.
          const shadowRoot = this.attachShadow({ mode: `open` });
          const instance = pbplugintemplate.content.cloneNode(true);
          shadowRoot.appendChild(instance);


          this.loadandBuildPlugin();
        }

        /**
         * Intanciate the fetched plugin, its GUI and make it available into the PDB by wrapping it into the PBPlugin model
         * */
        loadandBuildPlugin() {
          var pedal = this;
          var wrapper = this.shadowRoot.querySelector(".laPedale");
          try {
            this.plugin = new window[_pluginName](GlobalContext.context, _pluginUrl);

          } catch (error) {
            console.warn("WAP plugin implementation changes : replace your module definition by window.mymodule");
            this.plugin = new WAPlugin[_pluginName](GlobalContext.context, _pluginUrl);

          }

          // Load and loadGUI are defined in the SDK, it makes the audio part being the main part and the WC part just a connected wrap
          // LOAD NODE
          this.plugin.load().then((node) => {
            // LOAD GUI

            this.plugin.loadGui().then((elem) => {

              //Store the node as a field of the PBPlugin
              this.node = node;

              // Get the I/O numbers of the plugin
              this.nbNodeIn = node.numberOfInputs;
              this.nbNodeOut = node.numberOfOutputs;

              // Push the Inputs to the Inputs array 
              for (var i = 1; i < this.nbNodeIn; i++) {
                let tmp = "nodein" + i;
                pedal[tmp] = GlobalContext.context.createGain();
                pedal.nodeintab.push(pedal[tmp]);
              }

              try {
                // the "properties" method is recommended to set width and height of your wc
                this.w = elem.properties.dataWidth.value;
                this.h = elem.properties.dataHeight.value;
              } catch (error) {
                console.log(error);
                try {
                  // temporary fix for wams
                  this.w = node._gui.width;
                  this.h = node._gui.height;
                } catch (error) {
                  console.log("the dx7 has not proper width", error);
                }
              }
              // the WC is added to the pbplugin wrapper
              wrapper.appendChild(elem);

              // We now run the methods wich allows the node to be usable in this pedalboard (add graphical I/O, draggable class)
              this.runBehaviorMethods();

              // Set plugin state (if it's restored)
              if (Object.keys(this.paramsLoaded).length > 0) {
                this.node.setState((this.paramsLoaded));
              }
              // Connection between the node instanciated and it's PBPlugin wrapper
              if (this.nbNodeIn > 0) {
                // If the plugin has Input(s)
                if (this.nbNodeIn > 1) {
                  // If it has more than one each node input is connected to an input of the wrapper
                  for (let i = 0; i < pedal.nodeintab.length; i++) {
                    pedal.nodeintab[i].connect(node.inputs[i]);
                  }
                } else {
                  // If node has only one input the default soundNodeIn of the PBPlugin wrapper is connected
                  pedal.soundNodeIn.connect(node);
                }
              }

              
              // fisrt implementation to catch plugin singularities
              try {
                node.gui.onchange = () =>{ 
                  this.setAttribute("dynamicparams", node.dynamicParam.listento);
                };
                
              } catch (error) {
                console.log(error);
              }


              // Currently we manage only one output by node so we automatically connect the node output to the default PBPlugin soundnodeout
              node.connect(pedal.soundNodeOut);
            });
          });
        }

      });
    };
  }


</script>