<template>
  <link rel="stylesheet" href="./src/plugins/_utils/css/shared-styles.css">
  <div class="laPedale">
  </div>
</template>
<script>UseWebAudioControlsMidi = 1</script>
<script>

  const _currentdoc = document.currentScript.ownerDocument;

  class factory {

    createPedal(_tagName, _pluginName,_pluginUrl) {

      // Current document needs to be defined to get DOM access to imported HTML
      const template = _currentdoc.querySelector(`template`);
      // var script = document.createElement('script');
      // script.src = _pluginUrl + `main.js`;
      // console.log(script);
     // document.head.appendChild(script);

      // Register the x-custom element with the browser
      customElements.define(_tagName, class extends PBPlugin(HTMLElement) {

        // ----- METHODS: DEFAULT -----
        // is called when an instance of the element is created
        constructor() {
          // Toujours appeler "super" d'abord dans le constructeur
          super();

          // Ecrire la fonctionnalité de l'élément ici
          this.w = 140;
          this.h = 180;

          this.nbNodeIn = 1;
          this.nbNodeOut = 1;
          this.plugin;
        }

        get is() { return this.nodeName.toLowerCase(); }

        // observedAttributes : Specify observed attributes so that attributeChangedCallback will work
        static get observedAttributes() { return ['']; }

        // appelé lorsque l'un des attributs de l'élément personnalisé est ajouté, supprimé ou modifié.
        attributeChangedCallback() {
          console.log(`Custom element ${this.is} attributes changed.`);
        }

        // appelé lorsque l'élément personnalisé est déplacé vers un nouveau document
        adoptedCallback() {
          console.log(`Custom element ${this.is} moved to new page.`);
        }

        // appelé lorsque l'élément personnalisé est déconnecté du DOM du document 
        disconnectedCallback() {
          console.log(`Custom element ${this.is} removed from page.`);
          console.log(this.plugin.plug);
          if(this.plugin.plug instanceof AudioWorkletNode) this.soundNodeIn.disconnect(this.plugin.plug);
          else this.soundNodeIn.disconnect(this.plugin.plug.getInput(0));
          this.plugin.plug.disconnect(this.soundNodeOut);
          delete this.plugin;

        }

        // is called every time the element is inserted into the DOM. It is useful for running setup code, such as fetching resources or rendering.
        // appelé lorsque l'élément personnalisé est connecté pour la première fois au DOM du document
        connectedCallback() {
          console.log(`Custom element ${this.is} added to page.`);
          console.log(this);

          // Select the template and clone it. Finally attach the cloned node to the shadowDOM's root.
          const shadowRoot = this.attachShadow({ mode: `open` });
          const instance = template.content.cloneNode(true);
          shadowRoot.appendChild(instance);
          this.runBehaviorMethods();
          this.createAllInternNodes();
        }

        // ----- METHODS: CUSTOM -----
        createAllInternNodes() {
          var pedal = this;
          var wrapper = this.shadowRoot.querySelector(".laPedale");
          var pluginURL = _pluginUrl;
         // script.onload = () => {
            this.plugin = new WAPlugin[_pluginName](GlobalContext.context, pluginURL);
            this.plugin.load().then((node) => {
              this.plugin.loadGui().then((elem) => {
                this.w = elem.properties.dataWidth.value;
                this.h = elem.properties.dataHeight.value;
                wrapper.appendChild(elem);
              });
              if(node instanceof AudioWorkletNode) pedal.soundNodeIn.connect(node);
              else pedal.soundNodeIn.connect(node.getInput(0));
              node.connect(pedal.soundNodeOut);
            });
        }
      });
    }

  }

</script>